/*Chrome*/function sendMessage(sender, msg) {  chrome.tabs.sendMessage(sender.tab.id, msg);}function handleMessage(message, sender) {  console.log(message);  switch (message.command) {    case "getSettings":      sendMessage(sender, {        "command": "rec_getSettings", "data": {          "uid":myApp.settings.uid,          "email":myApp.settings.email,          "country":myApp.settings.country,          "toRecheck":myApp.settings.toRecheck,          "postedRecordCount":myApp.settings.postedRecordCount,        }      });      break;    case "saveUid":      myApp.settings.uid          = message.data.uid;      myApp.settings.email        = message.data.email;      myApp.settings.country      = message.data.country;      myApp.settings.dontRecheck  = message.data.dontRecheck;      myApp.settings.lastWeekChecked     = message.data.timestamp;      myApp.settings.onHold       = false;      myApp.save();      myApp.process();// u can start processing now..      break;  }}chrome.runtime.onMessage.addListener(handleMessage);var version = "3.0.0";var xmlhttp=new XMLHttpRequest, isAdblock=true;var recordsToPost = 30;var timegap = 1;// in secs diff btw multiple requestsvar hadNoConnection = false;myApp = {  settings: {    websiteList: [],    failedWebsiteList: [],    websiteListIndex: 0,    uid : 0,    email: "",    country:"",    dontRecheck: false,    lastWeekChecked:0,    records:[],    postedRecordCount:0,    onHold: true,    retryMode: false,  },  redirects : [],  curRequestId:0,  isTimedOut: false,  reloadScheduled: false,    load: function(){    this.initStorage();    this.checkWeek();    setTimeout(this.checkReload, 1000*60*5);// 1 hour    this.process();   // auto handle based on hold or not..  },  save: function(){    localStorage["settings"] = JSON.stringify(myApp.settings);  },  initStorage: function(){    var storedVersion = localStorage["version"];    if(storedVersion !== version){      localStorage["settings"] = JSON.stringify(myApp.settings);      localStorage["version"] = version;    }else      myApp.settings  = JSON.parse(localStorage["settings"]);  },  // just to check until we have no ID  checkWeek: function(){    if(myApp.settings.dontRecheck == true) return;    var curDate = new Date().getTime();    myApp.settings.onHold = true;    myApp.forceSettingsPage();    if(curDate - parseInt(myApp.settings.lastWeekChecked) >= 1000*3600*24*7*4){ //month=1000*3600*24*7*4    }    setTimeout(myApp.checkWeek, 1000*60*10);//10 mins  },    forceSettingsPage: function(){    chrome.windows.get(chrome.windows.WINDOW_ID_CURRENT, {"populate" : true}, function (winTabs) {      var i;      for (i = 0; i < winTabs.tabs.length; ++i) {        if (winTabs.tabs[i].title == "BlockedOnline Chrome Extension Settings") {          chrome.tabs.update(winTabs.tabs[i].id, {"active" : true}, null);          return;        }      }      chrome.tabs.create({"url" : "Settings.html"});    });  },    checkReload: function(){    if(myApp.settings.onHold == true) return; // its on Hold due to just installed..    if(myApp.reloadScheduled == false){      console.log("reloadScheduled..");      myApp.reloadScheduled = true;      setTimeout(myApp.checkReload, 1000*60);// 1 minute warning to become ready for reload    }else{      myApp.save();      console.log("App reloaded..");      chrome.runtime.reload();    }  },  //separate function so that it can be timed out..  moveOn: function(){    if(myApp.reloadScheduled == true) return;    if(myApp.settings.records.length >= recordsToPost){      myApp.postRecords();    }else{      myApp.process();            }      },  // main process to handle all movements once any AJAX request is completed..  process: function(){    if(myApp.reloadScheduled == true) return; // reloadScheduled    if(myApp.settings.onHold == true) return; // its on Hold        // set retryMode if current website list is finished..    if( myApp.settings.websiteListIndex == myApp.settings.websiteList.length ||         myApp.settings.websiteListIndex < 0){      console.log("websiteList last index reached..");      if(myApp.settings.retryMode == false){        // enable retryMode, transfer failedWebsiteList => websiteList, start again..        console.log("retryMode activated");        myApp.settings.retryMode = true;        myApp.settings.websiteList = myApp.settings.failedWebsiteList.slice();        myApp.settings.failedWebsiteList.length = 0;        myApp.settings.websiteListIndex = 0;        myApp.save();        setTimeout(myApp.process, 1500);// start again with failed list           }else{        //reset and get new websiteList        console.log("websiteList finished.. after retrying");        myApp.settings.retryMode = false;        myApp.settings.websiteList.length = 0;        myApp.settings.failedWebsiteList.length = 0;        myApp.settings.websiteListIndex = 0;        myApp.save();        setTimeout(myApp.getWebsiteList, 1500);// fetch new websiteList now as its emptied 2nd time      }      return;    }    if(xmlhttp.readyState !== 0 && xmlhttp.readyState !== 4){      console.log("xmlhttp busy..");      return;    }    var authUrl = myApp.settings.websiteList[myApp.settings.websiteListIndex];// + "?kiarash=true";    //xmlhttp = new XMLHttpRequest;    xmlhttp.startTime = new Date().getTime();    xmlhttp.open("GET", authUrl, true);    xmlhttp.setRequestHeader('Content-type', 'text/html; charset=iso-8859-1');    xmlhttp.onreadystatechange = myApp.websiteFetched;    xmlhttp.ontimeout = myApp.websiteTimedOut;    xmlhttp.timeout = 10000;    myApp.redirects = [];    myApp.curRequestId = 0;    myApp.isTimedOut = false;    xmlhttp.send(null);      },  // this is to manually force AJAX callback to be called if request is cancelled or timed out..  websiteTimedOut: function(){    console.log("timed out..");    myApp.isTimedOut = true;  },  // when any website is fetched..  websiteFetched: function(){    if(this.readyState == 4) {      // just add record everytime a website is fetched..      var record = {};      record.epoch        = new Date().getTime();      record.url          = myApp.settings.websiteList[myApp.settings.websiteListIndex];      record.final_url    = myApp.redirects[myApp.redirects.length-1] || "";      record.elapsed      = (record.epoch - this.startTime)/1000;      record.history      = JSON.stringify(myApp.redirects);      record.length       = this.responseText.length;      record.status_code  = this.status;      var o={}, t, h      = this.getAllResponseHeaders().split("\r\n");      h.forEach(function(el, i, ar){        if(el !=""){          t = el.split(":");          o[t[0]] = t[1]        }      });      record.headers    = JSON.stringify(o);      record.content    = this.responseText.slice(0,1000);      myApp.settings.records.push(record);      console.log("website fetched:-", record.url);      setTimeout(function(){        // cookieFetched will take over this..        chrome.cookies.getAll({url:record.url}, myApp.cookieFetched);      },1000);    }  },  cookieFetched: function(arrCookie){    var lastRecord = myApp.settings.records[myApp.settings.records.length-1];    lastRecord.cookies = JSON.stringify(arrCookie);    console.log("cookie fetched :-",lastRecord.url,lastRecord.status_code,myApp.settings.records.length );        if(lastRecord.status_code == 0){      isAdblock = true;      myApp.checkConnection();// checkConnection to see if its a timeout or not..    }else{      // if status != 0, just save that record and move forward with whatever response server sent      console.log("record created :-", lastRecord.url);      myApp.settings.websiteListIndex++;      myApp.save();      setTimeout(myApp.moveOn, 1000*timegap);// 20 secs    }  },  blockRequest: function(){    if(isAdblock  == false) return;    console.log("connection blocked retrying");    isAdblock = true;    xmlhttp.abort();  },  // to make ajax request to check connection once website has status 0  checkConnection: function(){    if(myApp.reloadScheduled == true) return; // reloadScheduled    console.log("checking connection");    if(xmlhttp.readyState !== 0 && xmlhttp.readyState !== 4){      console.log("xmlhttp busy..");      return;    }    //xmlhttp.open("GET", "http://chrome.blockedonline.net/ping/", true);    xmlhttp.open("GET", "http://basicstate.com/?t=" + (new Date().getTime()), true);    xmlhttp.onreadystatechange = myApp.connectionChecked;    xmlhttp.timeout = 10000;    setTimeout(myApp.blockRequest, 15000);    xmlhttp.send(null);  },  connectionChecked: function(){    console.log("connection checked status:-", this.readyState, this.status);    if(this.readyState == 4) {      console.log("connection check complete..");      isAdblock = false;      if(this.status == 0){        // we have connection problem, abort everything for half an hour        //delete the lastRecord in records and call process after 1 hour        console.log("NO connection... checking again soon");        if(hadNoConnection == false){          myApp.settings.records.length = myApp.settings.records.length - 1;          myApp.save();        }        hadNoConnection = true;        setTimeout(myApp.checkConnection, 1000*60); // 1 min      }else{        if(hadNoConnection == true){          setTimeout(myApp.process, 1000*10); // 10 secs          hadNoConnection = false;          return;        }        hadNoConnection = false;        if(myApp.settings.retryMode == false){          myApp.settings.failedWebsiteList.push(myApp.settings.websiteList[myApp.settings.websiteListIndex]);          console.log("website loading failed:- ",                       myApp.settings.websiteList[myApp.settings.websiteListIndex],                      myApp.settings.failedWebsiteList.length);                    // delete the lastRecord as its gone in retry list          myApp.settings.records.length = myApp.settings.records.length - 1;          myApp.settings.websiteListIndex++;          myApp.save();          setTimeout(myApp.moveOn, 1000*timegap);// 20 secs        }else{          //record the status 0 on website..          var r = myApp.settings.records[myApp.settings.records.length-1];          console.log("website has status 0 :-", r.url);          r.epoch = new Date().getTime();          r.final_url = 0;          r.length = 0;          r.elapsed = 0;          r.headers = 0;          r.cookies = 0;          r.status_code = 0;          r.content = 0;          if(myApp.isTimedOut == true){            r.history = "timed out";          }else{            r.history = "dns failure";          }                  console.log("website failure ..",r.url);          myApp.settings.websiteListIndex++;          myApp.save();          setTimeout(myApp.moveOn, 1000*timegap);// 20 secs               }      }    }  },  postRecords: function(){    if(myApp.reloadScheduled == true) return; // reloadScheduled    console.log("posting records ", myApp.settings.records.length);    if(myApp.settings.onHold == true) return; // its on Hold    if(xmlhttp.readyState !== 0 && xmlhttp.readyState !== 4){      console.log("xmlhttp busy..");      return;    }    //xmlhttp = new XMLHttpRequest;    var authData = JSON.stringify({      "uid": myApp.settings.uid,      "report" : myApp.settings.records    });    var authUrl = "http://chrome.blockedonline.net/report";    xmlhttp.recordCount = myApp.settings.records.length;    xmlhttp.open("POST", authUrl, true);    xmlhttp.setRequestHeader("Content-Type", "application/json; charset:iso-8859-1");    xmlhttp.onreadystatechange = myApp.recordsPosted;    xmlhttp.send(authData);    },  recordsPosted: function(){    if (this.readyState == 4) {      if(this.status == 0){        // assume connection error on kiarash site        console.log("Connection error in posting records..");        myApp.save();        setTimeout(myApp.postRecords, 1000*60*2); // 2 min = 1000*60*2        return;      }      if(this.status == 200){        console.log("records posted successfully..");        // records posted        myApp.settings.records.length = 0;        myApp.settings.postedRecordCount = myApp.settings.postedRecordCount + this.recordCount;        myApp.save();                setTimeout(myApp.moveOn, 1000*timegap);// 20 secs      }else{        //setTimeout(myApp.postRecords, 1000*20);// retry posting records        console.log("code error in posting records..resetting");        myApp.settings.records.length = 0;        myApp.settings.websiteListIndex = myApp.settings.websiteListIndex - recordsToPost;        myApp.save();        setTimeout(myApp.moveOn, 1000*timegap);// 20 secs      }    }  },  // this is for chrome API to record all redirects via AJAX  onBeforeRequest: function(details){    if(details.requestId == myApp.curRequestId){      myApp.redirects.push(details.url);    }    if(details.tabId == -1 && details.type == "xmlhttprequest" &&        details.url.indexOf(myApp.settings.websiteList[myApp.settings.websiteListIndex]) == 0){      myApp.redirects.push(details.url);      myApp.curRequestId = details.requestId;    }  },  getWebsiteList: function(){    if(myApp.reloadScheduled == true) return; // reloadScheduled    console.log("getting website list..");    if(myApp.settings.onHold == true) return; // its on Hold    if(xmlhttp.readyState !== 0 && xmlhttp.readyState !== 4){      console.log("xmlhttp busy..");      return;    }    //xmlhttp = new XMLHttpRequest;    var authData = [      "uid=" + myApp.settings.uid,      "load_count=" + 100    ].join("&");    var authUrl = "http://chrome.blockedonline.net/load?" + authData;    //var authUrl = "http://localhost/test/Test.php";    xmlhttp.open("GET", authUrl, true);    xmlhttp.onreadystatechange = myApp.websiteListFetched;    xmlhttp.send(null);  },  websiteListFetched: function(){    if (this.readyState == 4) {      console.log("websiteListFetched..");      if(this.status == 0){        // assume connection error on kiarash site        myApp.save();        setTimeout(myApp.getWebsiteList, 1000*60*2);         return;      }            if(this.status == 200){        console.log("got new 1000 websites..");        var r = JSON.parse(this.responseText);        if(r.uid !== undefined){          myApp.settings.websiteList = r.websites;          myApp.settings.websiteListIndex = 0;          myApp.settings.records.length = 0;          myApp.settings.retryMode = false;          myApp.save();          setTimeout(myApp.moveOn, 1000*timegap);// 20 secs  start processing websites one by one        }else{          setTimeout(myApp.getWebsiteList, 1000*30);// retry        }      }else{        setTimeout(myApp.getWebsiteList, 1000*30);// retry      }    }  },}chrome.webRequest.onBeforeRequest.addListener(myApp.onBeforeRequest,{urls: ["<all_urls>"]} );myApp.load();